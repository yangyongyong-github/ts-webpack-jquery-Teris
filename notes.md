
> 前言：
练习该项目，不为项目本身，而是过程中处理问题的思路的学习
做出项目只是很少的一部分，更重要的是去学习 处理遇到问题的思考和方法

# Game-RussiaBox


3. SquareGroup
4. boxProduct  shape种类的预定义 随机产生各个形状
Teris.ts  

5. 移动和旋转的规则判断：边界判断
TerisRules.ts
GameConfig.ts 配置真个面板的宽高
超过边界：至少有一个方块的坐标超出了面板范围
some 有一个即可

根据当前形状 产生一个新的形状
shape
afterRotateShape(): {}

6. **旋转 以及重写Shape类** 
难点在于 部分形状不适合普通的90deg旋转，以及旋转后 边界问题

rotate: 顺（90deg）
核心为算法思维的实现，数学（基础数学）
使用代码实现这个想法即可

x, y -> -y, x
有些方块时不旋转的，否则出问题
- 四个方框组合的方块，中心点在其中一个上，旋转出问题
一个小方块就是最小单位，不存在真正的点

有些方块在旋转时，只有两种状态
    长条的（四个并排组合）：只有两种状态
    上面两个，下面两个，错开


# 这里的编写思想：不再是原始的 首先判断 是否能旋转，在去旋转等，这样会使得类变得尤其复杂，违反了单一职责得原则
我们要用重写，在一些特殊的类中，重写一些方法来完成
这种思想也可以运用到形状的创建上

一个类含有各种情况时：使用父子类+重写来完成，而且易扩展
不要使用一个类中书写各种情况的复杂的类

> SquareGroup.ts 
    afterRotateShape(){
        protected isClock = true; // 是否为 顺时针 90deg

    /**
     * 旋转之后的形状
     */
    afterRotateShape(): Shape { }
 // 开始旋转
    rotate() {

}

> TerisRules.ts 完成旋转的边界判断部分


游戏的状态，使用枚举类型
types.tx
先不要考虑界面显示，先把数据的逻辑做好
Setinterval 报错，推断出为node环境，这里 删除node_modukes中的node即可

OOP实际上是降低了难度，利于功能的改变和迁移（手机端等）
游戏的难度是本身带来的，这种避免不了，OOP已经降低了

# 触底处理
界面最底部或者下面已经有方块了

一处一行的处理：
界面移除、数组中移除，剩余方块（filter: box: y<cur.y）坐标的处理（落下来，y+1）

界面的数据分离原则：
GameConfig.ts 
 panelSize: {
        width: 12,
        height: 20
    },
    nextSize: {
        width: 6,
        height: 6
    },
逻辑宽度和数据显示宽度是分来的
